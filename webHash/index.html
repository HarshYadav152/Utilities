<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hash Generator</title>
  <style>
    :root{--bg:#f6f8fa;--card:#fff;--text:#0b1220;--muted:#6b7280;--accent:#2563eb}
    *{box-sizing:border-box}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:var(--bg);color:var(--text);display:flex;align-items:center;justify-content:center;height:100vh;padding:20px}
    .card{background:var(--card);width:100%;max-width:800px;border-radius:12px;padding:20px;box-shadow:0 6px 18px rgba(10,20,40,0.08)}
    h1{margin:0 0 8px;font-size:18px}
    p.lead{margin:0 0 16px;color:var(--muted);font-size:13px}
    .row{display:flex;gap:12px;align-items:center;margin-bottom:12px;flex-wrap:wrap}
    textarea{width:100%;min-height:140px;padding:12px;border-radius:8px;border:1px solid #e6e9ef;font-size:14px;resize:vertical}
    select,input[type="checkbox"]{padding:8px;border-radius:8px;border:1px solid #e6e9ef;font-size:14px}
    .controls{display:flex;gap:8px;align-items:center}
    button{background:var(--accent);color:#fff;border:0;padding:10px 14px;border-radius:8px;cursor:pointer;font-weight:600}
    button.secondary{background:#eef2ff;color:var(--accent);border:1px solid rgba(37,99,235,0.12)}
    .output{margin-top:12px;padding:12px;border-radius:8px;background:#0b12201a;word-break:break-all;display:flex;gap:8px;align-items:center;justify-content:space-between}
    .hash-text{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;color:#042a60;flex:1}
    .meta{font-size:12px;color:var(--muted);margin-top:8px;display:flex;justify-content:space-between;align-items:center}
    .small{font-size:12px;color:var(--muted)}
    @media(max-width:560px){.row{flex-direction:column;align-items:stretch}.controls{flex-direction:column;align-items:stretch}}
  </style>
</head>
<body>
  <div class="card" role="main">
    <h1>Hash Generator</h1>
    <p class="lead">Enter text, choose algorithm, and generate the hash. Uses Web Crypto for SHA algorithms and a JS MD5 implementation.</p>

    <label for="inputText" class="small">Input text</label>
    <textarea id="inputText" placeholder="Type or paste text here..."></textarea>

    <div class="row">
      <div style="display:flex;gap:8px;align-items:center">
        <label for="algo" class="small">Algorithm</label>
        <select id="algo" aria-label="Hash algorithm">
          <option>SHA-1</option>
          <option selected>SHA-256</option>
          <option>SHA-384</option>
          <option>SHA-512</option>
          <option>MD5</option>
        </select>
      </div>

      <div style="display:flex;gap:8px;align-items:center">
        <label class="small"><input type="checkbox" id="live" /> Live update</label>
      </div>

      <div class="controls" style="margin-left:auto">
        <button id="generate">Generate</button>
        <button id="clear" class="secondary">Clear</button>
      </div>
    </div>

    <div class="output" aria-live="polite">
      <div class="hash-text" id="result">--</div>
      <div style="display:flex;flex-direction:column;gap:6px;margin-left:12px;">
        <button id="copy" class="secondary" style="min-width:80px">Copy</button>
        <button id="download" class="secondary" style="min-width:80px">Download</button>
      </div>
    </div>

    <div class="meta">
      <div class="small" id="length">Length: —</div>
      <div class="small">Browser Web Crypto used for SHA algorithms</div>
    </div>
  </div>

  <script>
    // Helper: convert ArrayBuffer to hex string
    function bufferToHex(buf) {
      const bytes = new Uint8Array(buf);
      let s = '';
      for (let i = 0; i < bytes.length; i++) {
        s += ('00' + bytes[i].toString(16)).slice(-2);
      }
      return s;
    }

    // Use SubtleCrypto for SHA algorithms
    async function shaDigest(algo, text) {
      const enc = new TextEncoder();
      const data = enc.encode(text);
      const digest = await crypto.subtle.digest(algo, data);
      return bufferToHex(digest);
    }

    // Minimal MD5 implementation (public-domain compact version)
    // Source: compact adaptation commonly used in browser utilities
    (function(){
      // We attach md5 to window via a compact implementation
      function cmn(q, a, b, x, s, t) {
        a = (a + q + x + t) | 0;
        return ((a << s) | (a >>> (32 - s))) + b;
      }
      function ff(a,b,c,d,x,s,t){return cmn((b & c) | ((~b) & d), a, b, x, s, t);}
      function gg(a,b,c,d,x,s,t){return cmn((b & d) | (c & (~d)), a, b, x, s, t);}
      function hh(a,b,c,d,x,s,t){return cmn(b ^ c ^ d, a, b, x, s, t);}
      function ii(a,b,c,d,x,s,t){return cmn(c ^ (b | (~d)), a, b, x, s, t);}
      function md51(s){
        let txt = '', n = s.length, state = [1732584193, -271733879, -1732584194, 271733878], i;
        for (i=64; i<=s.length; i+=64) {
          md5cycle(state, md5blk(s.substring(i-64, i)));
        }
        s = s.substring(i-64);
        const tail = new Array(16).fill(0);
        for (i=0;i<s.length;i++) tail[i>>2] |= s.charCodeAt(i) << ((i%4) * 8);
        tail[i>>2] |= 0x80 << ((i%4) * 8);
        if (i > 55) {
          md5cycle(state, tail);
          for (i=0; i<16; i++) tail[i] = 0;
        }
        tail[14] = n*8;
        md5cycle(state, tail);
        return state;
      }
      function md5blk(s) {
        const md5blks = [];
        for (let i=0; i<64; i+=4) {
          md5blks[i>>2] = s.charCodeAt(i) + (s.charCodeAt(i+1) << 8) + (s.charCodeAt(i+2) << 16) + (s.charCodeAt(i+3) << 24);
        }
        return md5blks;
      }
      function rhex(n){
        let s='', j=0;
        for(; j<4; j++) s += ('00' + ((n >> (j*8)) & 0xFF).toString(16)).slice(-2);
        return s;
      }
      function hex(x){
        for (let i=0;i<x.length;i++) x[i] = rhex(x[i]);
        return x.join('');
      }
      function md5cycle(x, k) {
        let a = x[0], b = x[1], c = x[2], d = x[3];
        a = ff(a, b, c, d, k[0], 7, -680876936);
        d = ff(d, a, b, c, k[1], 12, -389564586);
        c = ff(c, d, a, b, k[2], 17,  606105819);
        b = ff(b, c, d, a, k[3], 22, -1044525330);
        a = ff(a, b, c, d, k[4], 7, -176418897);
        d = ff(d, a, b, c, k[5], 12,  1200080426);
        c = ff(c, d, a, b, k[6], 17, -1473231341);
        b = ff(b, c, d, a, k[7], 22, -45705983);
        a = ff(a, b, c, d, k[8], 7,  1770035416);
        d = ff(d, a, b, c, k[9], 12, -1958414417);
        c = ff(c, d, a, b, k[10], 17, -42063);
        b = ff(b, c, d, a, k[11], 22, -1990404162);
        a = ff(a, b, c, d, k[12], 7,  1804603682);
        d = ff(d, a, b, c, k[13], 12, -40341101);
        c = ff(c, d, a, b, k[14], 17, -1502002290);
        b = ff(b, c, d, a, k[15], 22,  1236535329);

        a = gg(a, b, c, d, k[1], 5, -165796510);
        d = gg(d, a, b, c, k[6], 9, -1069501632);
        c = gg(c, d, a, b, k[11], 14, 643717713);
        b = gg(b, c, d, a, k[0], 20, -373897302);
        a = gg(a, b, c, d, k[5], 5, -701558691);
        d = gg(d, a, b, c, k[10], 9, 38016083);
        c = gg(c, d, a, b, k[15], 14, -660478335);
        b = gg(b, c, d, a, k[4], 20, -405537848);
        a = gg(a, b, c, d, k[9], 5, 560547926);
        d = gg(d, a, b, c, k[14], 9, -1019803690);
        c = gg(c, d, a, b, k[3], 14, -187363961);
        b = gg(b, c, d, a, k[8], 20,  1163531501);
        a = gg(a, b, c, d, k[13], 5, -1444681467);
        d = gg(d, a, b, c, k[2], 9, -51403784);
        c = gg(c, d, a, b, k[7], 14, 1735328473);
        b = gg(b, c, d, a, k[12], 20, -1926607734);

        a = hh(a, b, c, d, k[5], 4, -378558);
        d = hh(d, a, b, c, k[8], 11, -2022574463);
        c = hh(c, d, a, b, k[11], 16, 1839030562);
        b = hh(b, c, d, a, k[14], 23, -35309556);
        a = hh(a, b, c, d, k[1], 4, -1530992060);
        d = hh(d, a, b, c, k[4], 11, 1272893353);
        c = hh(c, d, a, b, k[7], 16, -155497632);
        b = hh(b, c, d, a, k[10], 23, -1094730640);
        a = hh(a, b, c, d, k[13], 4, 681279174);
        d = hh(d, a, b, c, k[0], 11, -358537222);
        c = hh(c, d, a, b, k[3], 16, -722521979);
        b = hh(b, c, d, a, k[6], 23, 76029189);
        a = hh(a, b, c, d, k[9], 4, -640364487);
        d = hh(d, a, b, c, k[12], 11, -421815835);
        c = hh(c, d, a, b, k[15], 16, 530742520);
        b = hh(b, c, d, a, k[2], 23, -995338651);

        a = ii(a, b, c, d, k[0], 6, -198630844);
        d = ii(d, a, b, c, k[7], 10, 1126891415);
        c = ii(c, d, a, b, k[14], 15, -1416354905);
        b = ii(b, c, d, a, k[5], 21, -57434055);
        a = ii(a, b, c, d, k[12], 6, 1700485571);
        d = ii(d, a, b, c, k[3], 10, -1894986606);
        c = ii(c, d, a, b, k[10], 15, -1051523);
        b = ii(b, c, d, a, k[1], 21, -2054922799);
        a = ii(a, b, c, d, k[8], 6, 1873313359);
        d = ii(d, a, b, c, k[15], 10, -30611744);
        c = ii(c, d, a, b, k[6], 15, -1560198380);
        b = ii(b, c, d, a, k[13], 21, 1309151649);
        a = ii(a, b, c, d, k[4], 6, -145523070);
        d = ii(d, a, b, c, k[11], 10, -1120210379);
        c = ii(c, d, a, b, k[2], 15, 718787259);
        b = ii(b, c, d, a, k[9], 21, -343485551);

        x[0] = (x[0] + a) | 0;
        x[1] = (x[1] + b) | 0;
        x[2] = (x[2] + c) | 0;
        x[3] = (x[3] + d) | 0;
      }
      function md5(s) { return hex(md51(unescape(encodeURIComponent(s)))); }

      window._md5 = md5;
    })();

    // UI wiring
    const input = document.getElementById('inputText');
    const algoEl = document.getElementById('algo');
    const generateBtn = document.getElementById('generate');
    const clearBtn = document.getElementById('clear');
    const resultEl = document.getElementById('result');
    const copyBtn = document.getElementById('copy');
    const downloadBtn = document.getElementById('download');
    const liveCb = document.getElementById('live');
    const lengthEl = document.getElementById('length');

    async function computeHash() {
      const text = input.value || '';
      const algo = algoEl.value;
      if (text === '') {
        resultEl.textContent = '--';
        lengthEl.textContent = 'Length: 0';
        return;
      }
      try {
        let hex;
        if (algo === 'MD5') {
          hex = window._md5(text);
        } else {
          // Map human label to subtle name
          const map = {'SHA-1':'SHA-1','SHA-256':'SHA-256','SHA-384':'SHA-384','SHA-512':'SHA-512'};
          hex = await shaDigest(map[algo], text);
        }
        resultEl.textContent = hex;
        lengthEl.textContent = 'Length: ' + (hex.length) + ' hex chars';
      } catch (e) {
        resultEl.textContent = 'Error: ' + (e && e.message || e);
        lengthEl.textContent = 'Length: —';
      }
    }

    generateBtn.addEventListener('click', computeHash);
    clearBtn.addEventListener('click', () => { input.value = ''; computeHash(); input.focus(); });
    algoEl.addEventListener('change', () => { if (liveCb.checked) computeHash(); });
    input.addEventListener('input', () => { if (liveCb.checked) computeHash(); });

    copyBtn.addEventListener('click', async () => {
      const text = resultEl.textContent;
      if (!text || text === '--') return;
      try {
        await navigator.clipboard.writeText(text);
        copyBtn.textContent = 'Copied';
        setTimeout(()=> copyBtn.textContent = 'Copy', 1200);
      } catch {
        // fallback
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        ta.remove();
        copyBtn.textContent = 'Copied';
        setTimeout(()=> copyBtn.textContent = 'Copy', 1200);
      }
    });

    downloadBtn.addEventListener('click', () => {
      const text = resultEl.textContent;
      if (!text || text === '--') return;
      const blob = new Blob([text], {type: 'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'hash.txt';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    // initialize
    computeHash();
  </script>
</body>
</html>
